
async function _by_evt(target, answer, pkt, ctx) ::
  /* target : on_mqtt_type = {
        mqtt_pkt(pkt, ctx) {}, // generic

        mqtt_auth(pkt, ctx) {},
        mqtt_connect(pkt, ctx) {},
        mqtt_connack(pkt, ctx) {},
        mqtt_disconnect(pkt, ctx) {},

        mqtt_publish(pkt, ctx) {},
        mqtt_subscribe(pkt, ctx) {},
        mqtt_unsubscribe(pkt, ctx) {},

        mqtt_pingreq(pkt, ctx) {},
        mqtt_pingresp(pkt, ctx) {},
    } */

  let pkt_fn = target[`mqtt_${pkt.type}`] || target.mqtt_pkt
  await pkt_fn?.call(target, pkt, ctx)

function _by_type(target, answer, pkt, ctx) ::
  answer(pkt.type, pkt)
  _by_evt(target, answer, pkt, ctx)

function _by_id(target, answer, pkt) ::
  answer(pkt.pkt_id, pkt)


export const _mqtt_cmdids = @[]
  _ => {}    // 0x0 reserved
  _by_evt   // 0x1 connect
  _by_type  // 0x2 connack
  _by_evt   // 0x3 publish
  _by_id    // 0x4 puback
  _by_id    // 0x5 pubrec
  _by_id    // 0x6 pubrel
  _by_id    // 0x7 pubcomp
  _by_evt   // 0x8 subscribe
  _by_id    // 0x9 suback
  _by_evt   // 0xa unsubscribe
  _by_id    // 0xb unsuback
  _by_type  // 0xc pingreq
  _by_type  // 0xd pingresp
  _by_evt   // 0xe disconnect
  _by_type  // 0xf auth

